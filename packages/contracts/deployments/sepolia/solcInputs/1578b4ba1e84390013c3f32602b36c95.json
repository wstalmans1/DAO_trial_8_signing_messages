{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Governance\n * @notice A simple governance contract for collaborative decision-making\n * @dev Step 6: Voting/Governance contract owned by multisig\n * \n * LEARNING POINT: This contract enables on-chain governance where proposals\n * can be created, voted on, and executed. The multisig controls the contract,\n * but proposals allow for structured decision-making.\n * \n * Key concepts:\n * - Proposals: Structured decisions that can be voted on\n * - Voting: Each proposal can be voted for/against\n * - Execution: Approved proposals can execute actions\n * - Quorum: Minimum votes required for a proposal to pass\n */\ncontract Governance is Ownable {\n    /**\n     * @notice Structure to represent a proposal\n     * @dev Contains all information about a governance proposal\n     */\n    struct Proposal {\n        uint256 id;                    // Unique proposal ID\n        address proposer;              // Who created the proposal\n        string description;            // Human-readable description\n        address target;                // Target contract for execution (if any)\n        bytes data;                   // Call data for execution (if any)\n        uint256 value;                // ETH value to send (if any)\n        uint256 forVotes;             // Number of votes in favor\n        uint256 againstVotes;          // Number of votes against\n        uint256 startTime;             // When voting starts\n        uint256 endTime;              // When voting ends\n        bool executed;                 // Whether proposal has been executed\n        bool cancelled;                // Whether proposal was cancelled\n        mapping(address => bool) hasVoted; // Track who has voted\n        mapping(address => bool) voteChoice; // true = for, false = against\n    }\n\n    // Proposal settings\n    uint256 public votingPeriod;      // How long voting lasts (in seconds)\n    uint256 public quorumThreshold;   // Minimum votes required (absolute number)\n    \n    // Proposal tracking\n    uint256 public proposalCount;     // Total number of proposals\n    mapping(uint256 => Proposal) public proposals; // proposal ID => Proposal\n    \n    // Events\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        string description,\n        address target,\n        uint256 value,\n        bytes data\n    );\n    \n    event VoteCast(\n        uint256 indexed proposalId,\n        address indexed voter,\n        bool support,  // true = for, false = against\n        uint256 forVotes,\n        uint256 againstVotes\n    );\n    \n    event ProposalExecuted(\n        uint256 indexed proposalId,\n        address indexed target,\n        uint256 value\n    );\n    \n    event ProposalCancelled(uint256 indexed proposalId);\n    event VotingPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event QuorumThresholdUpdated(uint256 oldThreshold, uint256 newThreshold);\n\n    /**\n     * @notice Constructor sets the initial owner and governance parameters\n     * @param initialOwner The address that will be the initial owner (multisig)\n     * @param _votingPeriod Voting period in seconds (e.g., 7 days = 604800)\n     * @param _quorumThreshold Minimum number of votes required for a proposal to pass\n     * \n     * LEARNING POINT: We set reasonable defaults for voting period and quorum.\n     * The voting period determines how long people have to vote.\n     * The quorum ensures enough participation for decisions to be valid.\n     */\n    constructor(\n        address initialOwner,\n        uint256 _votingPeriod,\n        uint256 _quorumThreshold\n    ) Ownable(initialOwner) {\n        require(_votingPeriod > 0, \"Governance: voting period must be greater than 0\");\n        require(_quorumThreshold > 0, \"Governance: quorum threshold must be greater than 0\");\n        \n        votingPeriod = _votingPeriod;\n        quorumThreshold = _quorumThreshold;\n    }\n\n    /**\n     * @notice Create a new proposal\n     * @dev Anyone can create a proposal, but only owner can execute\n     * @param description Human-readable description of the proposal\n     * @param target Target contract address (address(0) if no execution needed)\n     * @param value ETH value to send (0 if no ETH transfer)\n     * @param data Encoded function call data (empty if no execution)\n     * @return proposalId The ID of the created proposal\n     * \n     * LEARNING POINT: Creating a proposal doesn't execute anything.\n     * It just opens voting. After voting ends and quorum is met,\n     * the owner (multisig) can execute the proposal.\n     */\n    function createProposal(\n        string memory description,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) external returns (uint256 proposalId) {\n        require(bytes(description).length > 0, \"Governance: description cannot be empty\");\n        \n        proposalId = proposalCount;\n        proposalCount++;\n        \n        Proposal storage proposal = proposals[proposalId];\n        proposal.id = proposalId;\n        proposal.proposer = msg.sender;\n        proposal.description = description;\n        proposal.target = target;\n        proposal.value = value;\n        proposal.data = data;\n        proposal.startTime = block.timestamp;\n        proposal.endTime = block.timestamp + votingPeriod;\n        proposal.executed = false;\n        proposal.cancelled = false;\n        \n        emit ProposalCreated(proposalId, msg.sender, description, target, value, data);\n    }\n\n    /**\n     * @notice Vote on a proposal\n     * @dev Anyone can vote, but can only vote once per proposal\n     * @param proposalId The ID of the proposal to vote on\n     * @param support true = vote for, false = vote against\n     * \n     * LEARNING POINT: This implements simple binary voting (for/against).\n     * Each address can vote once. More sophisticated systems might use\n     * token-weighted voting or delegation.\n     */\n    function vote(uint256 proposalId, bool support) external {\n        Proposal storage proposal = proposals[proposalId];\n        \n        require(proposal.proposer != address(0), \"Governance: proposal does not exist\");\n        require(!proposal.cancelled, \"Governance: proposal has been cancelled\");\n        require(!proposal.executed, \"Governance: proposal has already been executed\");\n        require(block.timestamp >= proposal.startTime, \"Governance: voting has not started\");\n        require(block.timestamp <= proposal.endTime, \"Governance: voting has ended\");\n        require(!proposal.hasVoted[msg.sender], \"Governance: already voted\");\n        \n        proposal.hasVoted[msg.sender] = true;\n        proposal.voteChoice[msg.sender] = support;\n        \n        if (support) {\n            proposal.forVotes++;\n        } else {\n            proposal.againstVotes++;\n        }\n        \n        emit VoteCast(proposalId, msg.sender, support, proposal.forVotes, proposal.againstVotes);\n    }\n\n    /**\n     * @notice Execute a proposal\n     * @dev Only owner (multisig) can execute, and only if proposal passed\n     * @param proposalId The ID of the proposal to execute\n     * \n     * LEARNING POINT: Execution requires:\n     * 1. Voting period has ended\n     * 2. Quorum threshold is met (enough votes)\n     * 3. More for votes than against votes\n     * 4. Proposal hasn't been executed or cancelled\n     * \n     * The multisig must approve this execution, ensuring both parties\n     * agree to execute the proposal.\n     */\n    function executeProposal(uint256 proposalId) external onlyOwner {\n        Proposal storage proposal = proposals[proposalId];\n        \n        require(proposal.proposer != address(0), \"Governance: proposal does not exist\");\n        require(!proposal.cancelled, \"Governance: proposal has been cancelled\");\n        require(!proposal.executed, \"Governance: proposal has already been executed\");\n        require(block.timestamp > proposal.endTime, \"Governance: voting period has not ended\");\n        \n        uint256 totalVotes = proposal.forVotes + proposal.againstVotes;\n        require(totalVotes >= quorumThreshold, \"Governance: quorum not met\");\n        require(proposal.forVotes > proposal.againstVotes, \"Governance: proposal did not pass\");\n        \n        proposal.executed = true;\n        \n        // Execute the proposal if it has a target\n        if (proposal.target != address(0)) {\n            (bool success, ) = proposal.target.call{value: proposal.value}(proposal.data);\n            require(success, \"Governance: proposal execution failed\");\n        }\n        \n        emit ProposalExecuted(proposalId, proposal.target, proposal.value);\n    }\n\n    /**\n     * @notice Cancel a proposal (only owner)\n     * @dev Owner can cancel proposals before execution\n     * @param proposalId The ID of the proposal to cancel\n     * \n     * LEARNING POINT: The owner (multisig) can cancel proposals.\n     * This provides a safety mechanism if a proposal is problematic.\n     */\n    function cancelProposal(uint256 proposalId) external onlyOwner {\n        Proposal storage proposal = proposals[proposalId];\n        \n        require(proposal.proposer != address(0), \"Governance: proposal does not exist\");\n        require(!proposal.executed, \"Governance: proposal has already been executed\");\n        require(!proposal.cancelled, \"Governance: proposal has already been cancelled\");\n        \n        proposal.cancelled = true;\n        \n        emit ProposalCancelled(proposalId);\n    }\n\n    /**\n     * @notice Update voting period (only owner)\n     * @param newVotingPeriod New voting period in seconds\n     */\n    function setVotingPeriod(uint256 newVotingPeriod) external onlyOwner {\n        require(newVotingPeriod > 0, \"Governance: voting period must be greater than 0\");\n        \n        uint256 oldPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n        \n        emit VotingPeriodUpdated(oldPeriod, newVotingPeriod);\n    }\n\n    /**\n     * @notice Update quorum threshold (only owner)\n     * @param newQuorumThreshold New quorum threshold\n     */\n    function setQuorumThreshold(uint256 newQuorumThreshold) external onlyOwner {\n        require(newQuorumThreshold > 0, \"Governance: quorum threshold must be greater than 0\");\n        \n        uint256 oldThreshold = quorumThreshold;\n        quorumThreshold = newQuorumThreshold;\n        \n        emit QuorumThresholdUpdated(oldThreshold, newQuorumThreshold);\n    }\n\n    /**\n     * @notice Get proposal details\n     * @param proposalId The ID of the proposal\n     * @return id Proposal ID\n     * @return proposer Address of proposer\n     * @return description Proposal description\n     * @return target Target contract address\n     * @return value ETH value\n     * @return forVotes Number of for votes\n     * @return againstVotes Number of against votes\n     * @return startTime Voting start time\n     * @return endTime Voting end time\n     * @return executed Whether executed\n     * @return cancelled Whether cancelled\n     * \n     * LEARNING POINT: This view function allows anyone to check proposal status.\n     * Note: We can't return mappings directly, so we return individual values.\n     */\n    function getProposal(uint256 proposalId)\n        external\n        view\n        returns (\n            uint256 id,\n            address proposer,\n            string memory description,\n            address target,\n            uint256 value,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 startTime,\n            uint256 endTime,\n            bool executed,\n            bool cancelled\n        )\n    {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.proposer != address(0), \"Governance: proposal does not exist\");\n        \n        return (\n            proposal.id,\n            proposal.proposer,\n            proposal.description,\n            proposal.target,\n            proposal.value,\n            proposal.forVotes,\n            proposal.againstVotes,\n            proposal.startTime,\n            proposal.endTime,\n            proposal.executed,\n            proposal.cancelled\n        );\n    }\n\n    /**\n     * @notice Check if an address has voted on a proposal\n     * @param proposalId The ID of the proposal\n     * @param voter The address to check\n     * @return hasVoted Whether the address has voted\n     * @return voteChoice true if voted for, false if voted against (only valid if hasVoted is true)\n     */\n    function getVote(uint256 proposalId, address voter)\n        external\n        view\n        returns (bool hasVoted, bool voteChoice)\n    {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.proposer != address(0), \"Governance: proposal does not exist\");\n        \n        hasVoted = proposal.hasVoted[voter];\n        if (hasVoted) {\n            voteChoice = proposal.voteChoice[voter];\n        }\n    }\n\n    /**\n     * @notice Check if a proposal can be executed\n     * @param proposalId The ID of the proposal\n     * @return canExecute Whether the proposal can be executed\n     * @return reason Reason why it can't be executed (if applicable)\n     */\n    function canExecute(uint256 proposalId)\n        external\n        view\n        returns (bool canExecute, string memory reason)\n    {\n        Proposal storage proposal = proposals[proposalId];\n        \n        if (proposal.proposer == address(0)) {\n            return (false, \"Proposal does not exist\");\n        }\n        \n        if (proposal.cancelled) {\n            return (false, \"Proposal has been cancelled\");\n        }\n        \n        if (proposal.executed) {\n            return (false, \"Proposal has already been executed\");\n        }\n        \n        if (block.timestamp <= proposal.endTime) {\n            return (false, \"Voting period has not ended\");\n        }\n        \n        uint256 totalVotes = proposal.forVotes + proposal.againstVotes;\n        if (totalVotes < quorumThreshold) {\n            return (false, \"Quorum not met\");\n        }\n        \n        if (proposal.forVotes <= proposal.againstVotes) {\n            return (false, \"Proposal did not pass\");\n        }\n        \n        return (true, \"\");\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*",
          "evm.bytecode.object",
          "evm.deployedBytecode.object",
          "metadata",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}