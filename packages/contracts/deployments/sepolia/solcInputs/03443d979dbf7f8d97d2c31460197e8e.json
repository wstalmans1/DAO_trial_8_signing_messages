{
  "language": "Solidity",
  "sources": {
    "contracts/SimpleMultisig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title SimpleMultisig\n * @notice A simple 2-of-2 multisig wallet for collaboration\n * @dev Step 3: Learning how multisig wallets work\n * \n * LEARNING POINT: This is a simple multisig wallet that requires both parties\n * to approve any transaction before it can be executed. This ensures shared control.\n */\ncontract SimpleMultisig {\n    /**\n     * @notice Structure to represent a pending transaction\n     * @dev Stores transaction details until both parties approve\n     */\n    struct Transaction {\n        address to;           // Destination address\n        uint256 value;        // Amount of ETH to send (in wei)\n        bytes data;           // Call data (function call + parameters)\n        bool executed;        // Whether transaction has been executed\n        uint256 approvals;    // Number of approvals (0, 1, or 2)\n    }\n\n    // The two owners of this multisig wallet\n    address public owner1;\n    address public owner2;\n\n    // Mapping: transaction ID => Transaction details\n    mapping(uint256 => Transaction) public transactions;\n\n    // Mapping: transaction ID => owner address => has approved\n    mapping(uint256 => mapping(address => bool)) public approvals;\n\n    // Counter for transaction IDs\n    uint256 public transactionCount;\n\n    // Events\n    event TransactionCreated(\n        uint256 indexed transactionId,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    event TransactionApproved(\n        uint256 indexed transactionId,\n        address indexed approver\n    );\n\n    event TransactionExecuted(\n        uint256 indexed transactionId,\n        address indexed to,\n        uint256 value\n    );\n\n    /**\n     * @notice Constructor sets the two owners\n     * @param _owner1 First owner address\n     * @param _owner2 Second owner address\n     * \n     * LEARNING POINT: Both owners must be different addresses.\n     * This creates a 2-of-2 multisig where both must approve transactions.\n     */\n    constructor(address _owner1, address _owner2) {\n        require(_owner1 != address(0), \"SimpleMultisig: owner1 cannot be zero address\");\n        require(_owner2 != address(0), \"SimpleMultisig: owner2 cannot be zero address\");\n        require(_owner1 != _owner2, \"SimpleMultisig: owners must be different\");\n\n        owner1 = _owner1;\n        owner2 = _owner2;\n    }\n\n    /**\n     * @notice Modifier to check if caller is one of the owners\n     * @dev Only owner1 or owner2 can call functions with this modifier\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner1 || msg.sender == owner2,\n            \"SimpleMultisig: caller is not an owner\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Create a new transaction\n     * @dev Either owner can create a transaction, but both must approve to execute\n     * @param to Destination address for the transaction\n     * @param value Amount of ETH to send (in wei)\n     * @param data Call data (encoded function call)\n     * @return transactionId The ID of the created transaction\n     * \n     * LEARNING POINT: Creating a transaction doesn't execute it.\n     * Both owners must approve before it can be executed.\n     */\n    function createTransaction(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external onlyOwner returns (uint256 transactionId) {\n        require(to != address(0), \"SimpleMultisig: destination cannot be zero address\");\n\n        transactionId = transactionCount;\n        transactionCount++;\n\n        transactions[transactionId] = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            executed: false,\n            approvals: 0\n        });\n\n        emit TransactionCreated(transactionId, to, value, data);\n    }\n\n    /**\n     * @notice Approve a transaction\n     * @dev Each owner can approve once. When both approve, transaction can be executed.\n     * @param transactionId The ID of the transaction to approve\n     * \n     * LEARNING POINT: This is the core of multisig - both parties must approve.\n     * If you approve, you can't un-approve (for simplicity in this learning version).\n     */\n    function approveTransaction(uint256 transactionId) external onlyOwner {\n        Transaction storage transaction = transactions[transactionId];\n        require(transaction.to != address(0), \"SimpleMultisig: transaction does not exist\");\n        require(!transaction.executed, \"SimpleMultisig: transaction already executed\");\n        require(!approvals[transactionId][msg.sender], \"SimpleMultisig: already approved\");\n\n        // Mark this owner as having approved\n        approvals[transactionId][msg.sender] = true;\n        transaction.approvals++;\n\n        emit TransactionApproved(transactionId, msg.sender);\n    }\n\n    /**\n     * @notice Execute a transaction\n     * @dev Can only execute if both owners have approved (2-of-2 requirement)\n     * @param transactionId The ID of the transaction to execute\n     * \n     * LEARNING POINT: This is where the 2-of-2 requirement is enforced.\n     * Both owners must have approved before execution is possible.\n     */\n    function executeTransaction(uint256 transactionId) external onlyOwner {\n        Transaction storage transaction = transactions[transactionId];\n        require(transaction.to != address(0), \"SimpleMultisig: transaction does not exist\");\n        require(!transaction.executed, \"SimpleMultisig: transaction already executed\");\n        require(transaction.approvals == 2, \"SimpleMultisig: both owners must approve\");\n\n        // Mark as executed before external call (reentrancy protection)\n        transaction.executed = true;\n\n        // Execute the transaction\n        (bool success, ) = transaction.to.call{value: transaction.value}(transaction.data);\n        require(success, \"SimpleMultisig: transaction execution failed\");\n\n        emit TransactionExecuted(transactionId, transaction.to, transaction.value);\n    }\n\n    /**\n     * @notice Get transaction details\n     * @param transactionId The ID of the transaction\n     * @return transaction The transaction details\n     * \n     * LEARNING POINT: This is a view function - anyone can check transaction status.\n     */\n    function getTransaction(uint256 transactionId)\n        external\n        view\n        returns (Transaction memory transaction)\n    {\n        require(transactions[transactionId].to != address(0), \"SimpleMultisig: transaction does not exist\");\n        return transactions[transactionId];\n    }\n\n    /**\n     * @notice Check if an owner has approved a transaction\n     * @param transactionId The ID of the transaction\n     * @param owner The owner address to check\n     * @return True if the owner has approved\n     */\n    function hasApproved(uint256 transactionId, address owner)\n        external\n        view\n        returns (bool)\n    {\n        return approvals[transactionId][owner];\n    }\n\n    /**\n     * @notice Receive ETH\n     * @dev Allows the multisig wallet to receive ETH\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Get the balance of this multisig wallet\n     * @return The balance in wei\n     */\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*",
          "evm.bytecode.object",
          "evm.deployedBytecode.object",
          "metadata",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}